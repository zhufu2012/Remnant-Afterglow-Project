《《
1.对UnitBase 尝试使用 进程池，
2.把单位和其他实体分开

3.尝试将BaseObject转换为其他性能消耗更小的节点，或者不使用节点

4.实体需要有，粒子效果，确定性能足够后就加上来（尽量不使用节点）

6.单位加载场景，可以静态化

7.单位的刷新，不要一帧刷新完,换成一帧刷一个怪，这样应该帧率更平滑

8.空间网格没必要 每个单位每帧运行，可以修改为每俩帧运行，或更高，需要测试，理论上效果不会太差,  分离力保留一帧就可以了
9.空间网格的格子可能过大了，改成40试试，并且和第10条一起用，可以将网格简化到地图格子使用，（空间网格和地图格子用同一个位置）
另外，理论上一个单位只需要计算几个附近单位的力就可以了，不需要计算全部,比如6个或8个，
10.把单位分成三种占地大小的 场景，大，中，小，  然后就不必加载计算碰撞体大小,然后资源可以设置为唯一，直接读取即可，动画帧节点也不需要添加了，只需要计算


11.属性计算，改为每秒执行1次了，并且，开始前就应该缓存哪些属性需要每秒运行（缓存在一个唯一字典内，加载时就处理）

12.流场计算，理论上也不需要每帧读取，可以改为只要单位当前位置 和上一帧位置一样，流场计算就直接过滤部分计算(如旋转)

13.武器碰撞范围，在确定目标后，暂时关闭碰撞，无目标再打开


15.子弹用底层服务器绘制，不用精灵
》》

1.子弹可以改成2帧更新一次，生成一帧一次
14.碰撞的掩码，应该开局就计算完成，然后各阵营发射的子弹的层级不同，各阵营检测的层级也应该不同
0     1      2      3      4
1     2      3      4      5
      2 的占地    index:2      mask:13,14,15
      2 的武器    index:null   mask: 3,4,5
      2 的子弹    index:12     mask:null